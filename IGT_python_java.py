
#load decks
allCards = data.importConditions("CONDITIONS.xlsx")
A_cards = list(filter(lambda x: x["DECK_NAME"] == "A", allCards))
B_cards = list(filter(lambda x: x["DECK_NAME"] == "B", allCards))
C_cards = list(filter(lambda x: x["DECK_NAME"] == "C", allCards))
D_cards = list(filter(lambda x: x["DECK_NAME"] == "D", allCards))

totalReps = 100

###MAIN_EXP###
#Begin experiment
mycurrent=2000
curr_tot=2000
prev_tot=0

cardImg1 = "A.png"
cardImg2 = "B.png"
cardImg3 = "C.png"
cardImg4 = "D.png"
deckEmptyImg = "DECK_EMPTY.png"

# declare these variables, which are
# names of the image stims, so that
# the code will compile. They'll be
# given values later.
A = None
B = None
C = None
D = None
DECK_11 = None
DECK_21 = None
DECK_31 = None
DECK_41 = None

def deckClicked(deck, exp, mycurrent, deckStimToChange):
    # deck: the list of dictionaries for a deck, like A_cards
    # exp: going to be thisExp
    # deckStimToChange: the text stim that updates the messge
    #     for how much money was earned or lost
    currentCard = deck.pop(0)

    earnings = currentCard["EARNINGS"]
    losses = currentCard["LOSSES"]
    deckSelected = currentCard["DECK_NAME"]

    exp.addData('deck_selected', deckSelected)
    exp.addData('earnings', earnings)
    exp.addData('losses', losses)

    mycurrent = mycurrent + earnings + losses
    exp.addData('mycurrent', mycurrent)

    global ALL_FEEDBACK_TEXTS
    for c, d in enumerate(ALL_FEEDBACK_TEXTS):
        if d is deckStimToChange:
            d.text = u"You won {0:.0f} \nYou lost {1:.0f}".format(earnings, losses)
        else:
            d.text = "Deck {0}".format(c + 1)

    return mycurrent

#Begin routine
ALL_FEEDBACK_TEXTS = [deck11, deck22, deck33, deck44]

# This will be looped through to check if the decks
# are empty: [<nameOfCardDeck>, <list of image stims associated with deck>]
DECKS_AND_IMAGES = [[A_cards, [A, DECK_11]],
                    [B_cards, [B, DECK_21]],
                    [C_cards, [C, DECK_31]],
                    [D_cards, [D, DECK_41]],
                    ]

for deckIms in DECKS_AND_IMAGES:
    deck = deckIms[0]
    ims = deckIms[1]
    # check if deck is empty, if so, change image
    if not deck:
        for im in ims:
           im.image = deckEmptyImg

#Each frame
event.mouseButtons = [0, 0, 0]
print('start of each frame')
#if mouse.status == STARTED:  # only update if started and not stopped!
    #buttons = mouse.getPressed()
if mouse.isPressedIn(A):  # ie if any button is pressed
    if (A_cards):
    # abort routine on response
        prev_tot=mycurrent

        mycurrent = deckClicked(A_cards, thisExp, mycurrent, deck11)

        continueRoutine = False

elif mouse.isPressedIn(B):

    if (B_cards):

        prev_tot=mycurrent

        mycurrent = deckClicked(B_cards, thisExp, mycurrent, deck22)

        continueRoutine = False
elif mouse.isPressedIn(C):  # ie if any button is pressed

    if (C_cards):
        # abort routine on response
        prev_tot=mycurrent

        mycurrent = deckClicked(C_cards, thisExp, mycurrent, deck33)

        continueRoutine = False

elif mouse.isPressedIn(D):

    if (D_cards):

        prev_tot=mycurrent

        mycurrent = deckClicked(D_cards, thisExp, mycurrent, deck44)

        continueRoutine = False

else:
        continueRoutine = True

thisExp.addData('RT', t)


###FEEDBACK###
#End routine
if mouse_2.isPressedIn(mypolygon):
    continueRoutine = False
